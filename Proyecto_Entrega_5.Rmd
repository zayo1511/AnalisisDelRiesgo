---
title: "Proyecto Final: Parte 4"
author: "Rolando Fortanell Canedo<br>
         Luis Eduardo Jiménez del Muro<br>
         Diego Lozoya Morales<br>
         Lenin Adair Quezada Gómez"
date: "2025-04-25"
output: 
  html_document:
    toc: true
    toc_float: true
    embed-resources: true
    theme: cerulean
    highlight: tango
    code_folding: hide 
    code-link: true
editor_options: 
  markdown: 
    wrap: 72
---

# Librerías

```{r}
suppressPackageStartupMessages(library(quantmod))
suppressPackageStartupMessages(library(lubridate))

set.seed(123)
```

# Portafolio

```{r}
claves <- c("GCC.MX", "GFNORTEO.MX")
datos <- new.env()
getSymbols(claves, env = datos, to = "2025-04-08")

precio_gcc <- datos[[claves[1]]][, 6]
precio_gfnorteo <- datos[[claves[2]]][, 6]

vp_hist <- precio_gcc * 100 + precio_gfnorteo * 100
vo <- as.numeric(last(vp_hist))
g_p <- na.omit(diff(vp_hist))

rt_gcc <-  na.omit(diff(log(precio_gcc)))
rt_gfnorteo <- na.omit(diff(log(precio_gfnorteo)))

vo
```

# VaR no pramétrico

## Metodología histórica

### Estimación valores futuros y Función de péridas y ganancias

```{r}
precio_fgcc <- as.numeric(last(precio_gcc)) * (1 + rt_gcc)
precio_fgfnorteo <- as.numeric(last(precio_gfnorteo)) * (1 + rt_gfnorteo)

v_futuro <- 100 * precio_fgcc + 100 * precio_fgfnorteo
names(v_futuro) <- "valor_p"
```

```{r}
f_per_gan <- v_futuro-vo
hist(f_per_gan, n=100, col="cornflowerblue", main ="Pérdidas y ganancias")
```

### Cáluclo de VaR a 1 día

```{r}
VaR90 <- quantile(f_per_gan, 0.1)
VaR95 <- quantile(f_per_gan, 0.05)
VaR99 <- quantile(f_per_gan, 0.01)

VaR90
VaR95
VaR99
```

```{r}
hist(f_per_gan, n=100, col="cornflowerblue", main ="Pérdidas y ganancias")

abline(v=VaR90, col="indianred", lwd=2)
abline(v=VaR95, col="darkseagreen", lwd=2)
abline(v=VaR99, col="plum", lwd=2)

legend("topright", 
       legend = c(
         sprintf("VaR 90%%: %.4f", VaR90),
         sprintf("VaR 95%%: %.4f", VaR95),
         sprintf("VaR 99%%: %.4f", VaR99)
       ),
       col = c("indianred", "darkseagreen", "plum"), 
       lty = c(1, 1, 1), 
       lwd = 2, 
       bty = "n")
```

### VaR a diferentes horizontes

```{r}
horizontes <- c(1, 5, 10, 20)

VaRs90 <- sapply(horizontes, function(i) VaR90 * sqrt(i))
VaRs95 <- sapply(horizontes, function(i) VaR95 * sqrt(i))
VaRs99 <- sapply(horizontes, function(i) VaR99 * sqrt(i))

df_var <- data.frame(
  Días = horizontes,
  VaR_90 = VaRs90,
  VaR_95 = VaRs95,
  VaR_99 = VaRs99
)

df_var
```

### Backtesting

```{r}
BTP90 <- ifelse(g_p < VaR90, 1, 0)
BTP95 <- ifelse(g_p < VaR95, 1, 0)
BTP99 <- ifelse(g_p < VaR99, 1, 0)

var_sup_90 <- (sum(BTP90)/length(BTP90))*100
var_sup_95 <- (sum(BTP95)/length(BTP95))*100
var_sup_99 <- (sum(BTP99)/length(BTP99))*100

var_sup_90
var_sup_95
var_sup_99
```

## Metodología de simulación histórica

### Simulación de valores futuros y Función de péridas y ganancias

```{r}
epsilon <- rnorm(100000)

mu_gcc <- mean(rt_gcc)
sigma_gcc <- sd(rt_gcc)
S0_gcc <- as.numeric(last(precio_gcc))

mu_gfnorteo <- mean(rt_gfnorteo)
sigma_gfnorteo <- sd(rt_gfnorteo)
S0_gfnorteo <- as.numeric(last(precio_gfnorteo))

S_gcc <- S0_gcc * exp((mu_gcc - (1/2) * sigma_gcc^2) + sigma_gcc * epsilon)
S_gfnorteo <- S0_gfnorteo * exp((mu_gfnorteo - (1/2) * sigma_gfnorteo^2) + sigma_gfnorteo * epsilon)

v_futuro <- 100 * S_gcc + 100 * S_gfnorteo
f_per_gan <- v_futuro - vo
```

### Cáluclo de VaR a 1 día

```{r}
VaR90 <- quantile(f_per_gan, 0.1)
VaR95 <- quantile(f_per_gan, 0.05)
VaR99 <- quantile(f_per_gan, 0.01)

VaR90
VaR95
VaR99
```

```{r}
hist(f_per_gan, n=100, col="cornflowerblue", main ="Pérdidas y ganancias")

abline(v=VaR90, col="indianred", lwd=2)
abline(v=VaR95, col="darkseagreen", lwd=2)
abline(v=VaR99, col="plum", lwd=2)

legend("topright", 
       legend = c(
         sprintf("VaR 90%%: %.4f", VaR90),
         sprintf("VaR 95%%: %.4f", VaR95),
         sprintf("VaR 99%%: %.4f", VaR99)
       ),
       col = c("indianred", "darkseagreen", "plum"), 
       lty = c(1, 1, 1), 
       lwd = 2, 
       bty = "n")
```

### VaR a diferentes horizontes

```{r}
horizontes <- c(1, 5, 10, 20)

VaRs90 <- sapply(horizontes, function(i) VaR90 * sqrt(i))
VaRs95 <- sapply(horizontes, function(i) VaR95 * sqrt(i))
VaRs99 <- sapply(horizontes, function(i) VaR99 * sqrt(i))

df_var <- data.frame(
  Días = horizontes,
  VaR_90 = VaRs90,
  VaR_95 = VaRs95,
  VaR_99 = VaRs99
)

df_var
```

### Backtesting

```{r}
BTP90 <- ifelse(g_p < VaR90, 1, 0)
BTP95 <- ifelse(g_p < VaR95, 1, 0)
BTP99 <- ifelse(g_p < VaR99, 1, 0)

var_sup_90 <- (sum(BTP90)/length(BTP90))*100
var_sup_95 <- (sum(BTP95)/length(BTP95))*100
var_sup_99 <- (sum(BTP99)/length(BTP99))*100

var_sup_90
var_sup_95
var_sup_99
```

# VaR paramétrico

## Covarianza, pesos y volatilidad del portafolio

```{r}
R <- merge.xts(rt_gcc, rt_gfnorteo)
covarianza <- cov(R)
covarianza

w_gcc <- last(precio_gcc) * 100 / vo
w_gfnorteo <- last(precio_gfnorteo) * 100 / vo
w <- as.numeric(c(w_gcc, w_gfnorteo))
w

vol_p <- sqrt(w%*%covarianza%*%w)
vol_p
```

## Cálculo de VaR a 1 día

```{r}
z90 <- qnorm(0.10)
z95 <- qnorm(0.05)
z99 <- qnorm(0.01)

VaR90 <- vo * z90 * vol_p
VaR95 <- vo * z95 * vol_p
VaR99 <- vo * z99 * vol_p

VaR90
VaR95
VaR99
```

## VaR a diferentes horizontes

```{r}
horizontes <- c(1, 5, 10, 20)

VaRs90 <- sapply(horizontes, function(i) VaR90 * sqrt(i))
VaRs95 <- sapply(horizontes, function(i) VaR95 * sqrt(i))
VaRs99 <- sapply(horizontes, function(i) VaR99 * sqrt(i))

df_var <- data.frame(
  Días = horizontes,
  VaR_90 = VaRs90,
  VaR_95 = VaRs95,
  VaR_99 = VaRs99
)

df_var
```

## Backtesting

```{r}
BTP90 <- ifelse(g_p < as.numeric(VaR90), 1, 0)
BTP95 <- ifelse(g_p < as.numeric(VaR95), 1, 0)
BTP99 <- ifelse(g_p < as.numeric(VaR99), 1, 0)

var_sup_90 <- (sum(BTP90)/length(BTP90))*100
var_sup_95 <- (sum(BTP95)/length(BTP95))*100
var_sup_99 <- (sum(BTP99)/length(BTP99))*100

var_sup_90
var_sup_95
var_sup_99
```

# Portafolio de mínimo VaR

```{r}
# Paquete necesario
library(quadprog)

# 1. Calcula la matriz de covarianza
covarianza <- covarianza

# 2. Configura el problema cuadrático:
Dmat <- 2 * covarianza                     # Nota: quadprog minimiza (1/2)x'Dx, por eso 2*Sigma
dvec <- rep(0, ncol(covarianza))          # No hay parte lineal

# Restricciones:
Amat <- cbind(rep(1, ncol(covarianza)), diag(ncol(covarianza)))  # Suma de pesos = 1 y pesos ≥ 0
bvec <- c(1, rep(0, ncol(covarianza)))    # bvec para las restricciones

# 3. Resolver
sol <- solve.QP(Dmat, dvec, Amat, bvec, meq = 1)

# 4. Mostrar pesos óptimos
pesos_optimos <- sol$solution
print(pesos_optimos)
```



